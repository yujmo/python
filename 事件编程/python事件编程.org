* 事件驱动模型介绍
** 传统的编程模式
    开始--->代码块A--->代码块B--->代码块C--->代码块D--->......--->结束
** 事件驱动模型
    开始--->初始化--->等待


* 事件驱动模型
** 每收到一个请求，创建一个新的进程，来处理该请求；
** 每收到一个请求，创建一个新的线程，来处理该请求；
** 每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求


* 协程、事件驱动
** 问题引入：在UI编程中，常常要对鼠标点击进行相应，首先如何获得鼠标点击呢？
*** 创建一个线程循环检测是否有鼠标点击
**** 缺点：
***** CPU资源浪费，可能鼠标点击的频率非常小，但是扫描线程还是会一直循环检测，造成CPU资源浪费;
***** 扫描鼠标点击的接口是阻塞的，如果我们不但要扫描鼠标点击，还要扫描键盘是否按下，由于扫描鼠标时被堵塞了，那么可能永远不会去扫描键盘；
***** 如果一个循环需要扫描的设备非常多，这又会引来响应时间的问题。

*** 事件驱动模型：UI平台提供onClick()事件，代表鼠标按下事件
**** 事件驱动模型大体思路如下：
***** 有一个事件（消息）队列；
***** 鼠标按下时，往这个队列中增加一个点击事件（消息）；
***** 有个循环，不断从队列取出事件，根据不同的事件，调用不同的函数，如onClick()、onKeyDown()等；
***** 事件（消息）一般都各自保存各自的处理函数指针，这样，每个消息都有独立的处理函数；

** [[file:python事件编程1.png]]


* IO模型
** 用户空间和内核空间
** 进程切换：消耗资源
** 进程的阻塞
** 文件描述符
** 缓存IO

* 环境介绍：Linux环境下的network IO
** IO发生时涉及的对象和步骤：　
*** network IO (以read举例)，涉及到两个系统对象：调用这个IO的process(thread)、系统内核
*** 当read操作发生时，经历两个阶段：
**** 等待数据准备
**** 将数据从内核拷贝到进程中

* 常见的IO模型
+ blocking IO（阻塞IO）
+ nonblocking IO（非阻塞IO）
+ IO multiplexing（IO多路复用）
+ signal driven IO（信号驱动式IO）
+ asynchronous IO（异步IO）

** 不常用的IO模型
*** 信号驱动IO模型（Signal-driven IO）:使用信号，让内核在描述符就绪时发送SIGIO信号通知应用程序
 [[file:python事件编程2.jpg]]
+ 开启套接字的信号驱动式I/O功能，并通过sigaction系统调用安装一个信号处理函数。
+ 该系统调用将立即返回，进程继续工作，进程没有被阻塞。
+ 当数据报准备好读取时，内核就为该进程产生一个SIGIO信号。
+ 在信号处理函数中调用recvfrom读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。
**** 优势：等待数据报到达期间进程不被阻塞。主循环继续执行 ，只要等到来自信号处理函数的通知。
-----
** 常用的四种IO模型
*** blocking IO（阻塞IO模型）
[[file:python事件编程3.jpg]]
+ 当用户进程调用recvfrom，
+ kernel开始IO的第一个阶段：准备数据。
+ 对network IO，数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），
+ kernel就要等待足够的数据到来。
+ 在用户进程这边，整个进程会被阻塞。
+ 当kernel一直等到数据准备好，将数据从kernel中拷贝到用户内存，
+ 然后kernel返回结果，用户进程才解除block的状态，重新运行起来。
**** blocking IO的特点就是在IO执行的两个阶段都被block。

#+BEGIN_SRC python
## server
import socket
sk=socket.socket()
sk.bind(("127.0.0.1",8080))
sk.listen(5)
while 1:
    conn,addr=sk.accept()
    while 1:
        conn.send("hello client".encode("utf8"))
        data=conn.recv(1024)
        print(data.decode("utf8"))
#---------------------------------------------------------
## client
import socket
sk=socket.socket()
sk.connect(("127.0.0.1",8080))
while 1:
    data=sk.recv(1024)
    print(data.decode("utf8"))
    sk.send(b"hello server")
#+END_SRC
*** non-blocking IO(非阻塞IO)
 [[file:python事件编程4.jpg]]
+ 当用户进程发出read操作时，如果kernel中的数据未准备好，并不会block用户进程
+ 而是立刻返回一个error
+ 从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果
+ 用户进程判断结果是一个error时，它知道数据还没有准备好，于是它可以再次发送read操作
+ 一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，
+ 那么它马上就将数据拷贝到了用户内存，然后返回。
+ 所以，用户进程其实是需要不断的主动询问kernel数据好了没有。

**** 注意：
SCHEDULED: <2018-01-17 三>
- 在网络IO时候，非阻塞IO也会进行recvform系统调用，检查数据是否准备好，
- 与阻塞IO不一样，”非阻塞将大的整片时间的阻塞分成N多的小的阻塞,
- 所以进程不断地有机会 ‘被’ CPU光顾”。
- 即每次recvform系统调用之间，cpu的权限还在进程手中，这段时间是可以做其他事情的，
- 也就是说非阻塞的recvform系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，
- 如果数据还没准备好，此时会返回一个error。
- 进程在返回之后，可以执行其他的事情，然后再发起recvform系统调用。
- 重复上面的过程，循环往复的进行recvform系统调用。
- 这个过程通常被称之为轮询。
- 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。
- 需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。
#+BEGIN_SRC python

#+END_SRC
